#!/usr/bin/env -S uv run --script
"""
sway workspace-aware wallpaper daemon.
listens for workspace changes and sets per-output backgrounds
based on the first visible workspace on each output.
also decorates the focused window title.
"""

import json
import random
import subprocess
import hashlib
import signal
import sys
import os
import atexit
from pathlib import Path
from typing import Optional

CONFIG_PATH = Path("~/.config/sway/wallpapers.json").expanduser()
IMAGE_DIR = Path("~/lib/pics/wallpapers/marginalia").expanduser()
CACHE_DIR = Path("~/.cache/sway-wallpapers").expanduser()
PIDFILE = Path("~/.cache/sway-wallpaper-daemon.pid").expanduser()
BACKGROUND_COLOR = "#fdf6e3"
ACTIVE_WINDOW_TITLE = "<span size='10pt'>⸻ ❧ ꧁   ⁂   ꧂ ☙ ⸻</span>"
DEFAULT_TITLE_FORMAT = "<span size='10pt'>⸻ ❧ ꧁   %title   ꧂ ☙ ⸻</span>"


def kill_old_instance():
    if PIDFILE.exists():
        try:
            old_pid = int(PIDFILE.read_text().strip())
            os.kill(old_pid, signal.SIGTERM)
        except (ValueError, ProcessLookupError, PermissionError):
            pass  # stale pidfile or already dead
        PIDFILE.unlink(missing_ok=True)

    # murder any orphaned swaybg processes
    subprocess.run(["pkill", "-x", "swaybg"], capture_output=True)

    PIDFILE.write_text(str(os.getpid()))


class WallpaperDaemon:
    def __init__(self):
        self.config = self._load_config()
        self.swaybg_procs: dict[str, subprocess.Popen] = {}
        self.current_state: dict[str, tuple[str, Optional[Path]]] = {}  # output -> (workspace, image_path)
        self.workspace_image_cache: dict[str, dict] = {}  # workspace -> chosen image entry
        
        # focus title management
        self.modified_windows: set[int] = set()  # con_ids we've touched
        self.current_focused_id: Optional[int] = None
        
        CACHE_DIR.mkdir(parents=True, exist_ok=True)
        
        # ensure we restore titles on any exit
        atexit.register(self._restore_all_titles)

    def _load_config(self) -> dict:
        if not CONFIG_PATH.exists():
            raise FileNotFoundError(f"config not found: {CONFIG_PATH}")
        with open(CONFIG_PATH) as f:
            return json.load(f)

    def _get_outputs(self) -> list[dict]:
        result = subprocess.run(
            ["swaymsg", "-t", "get_outputs", "-r"],
            capture_output=True, text=True, check=True
        )
        return json.loads(result.stdout)

    def _get_workspaces(self) -> list[dict]:
        result = subprocess.run(
            ["swaymsg", "-t", "get_workspaces", "-r"],
            capture_output=True, text=True, check=True
        )
        return json.loads(result.stdout)

    def _get_focused_window(self) -> Optional[dict]:
        """get the currently focused container from sway tree"""
        result = subprocess.run(
            ["swaymsg", "-t", "get_tree", "-r"],
            capture_output=True, text=True, check=True
        )
        tree = json.loads(result.stdout)
        return self._find_focused(tree)

    def _find_focused(self, node: dict) -> Optional[dict]:
        """recursively find the focused leaf node"""
        if node.get("focused") and node.get("type") == "con" and not node.get("nodes"):
            return node
        for child in node.get("nodes", []) + node.get("floating_nodes", []):
            found = self._find_focused(child)
            if found:
                return found
        return None

    def _set_window_title(self, con_id: int, title: str):
        """set title for a specific container"""
        # escape for sway command parsing
        escaped = title.replace('"', '\\"')
        subprocess.run(
            ["swaymsg", f'[con_id={con_id}] title_format "{escaped}"'],
            capture_output=True, check=False  # don't fail if window died
        )

    def _restore_window_title(self, con_id: int):
        """restore default title format for a container"""
        if con_id not in self.modified_windows:
            return
        self.modified_windows.discard(con_id)
        escaped = DEFAULT_TITLE_FORMAT.replace('"', '\\"')
        subprocess.run(
            ["swaymsg", f'[con_id={con_id}] title_format "{escaped}"'],
            capture_output=True, check=False
        )

    def _restore_all_titles(self):
        """restore all modified titles - called on exit"""
        for con_id in list(self.modified_windows):
            self._restore_window_title(con_id)
        self.current_focused_id = None

    def _apply_default_title_to_all(self):
        """apply default title format to all existing windows on startup"""
        result = subprocess.run(
            ["swaymsg", "-t", "get_tree", "-r"],
            capture_output=True, text=True, check=True
        )
        tree = json.loads(result.stdout)
        for con_id in self._collect_leaf_con_ids(tree):
            escaped = DEFAULT_TITLE_FORMAT.replace('"', '\\"')
            subprocess.run(
                ["swaymsg", f'[con_id={con_id}] title_format "{escaped}"'],
                capture_output=True, check=False
            )
            self.modified_windows.add(con_id)

    def _collect_leaf_con_ids(self, node: dict) -> list[int]:
        """collect con_ids of leaf windows (actual apps, not containers)"""
        ids = []
        children = node.get("nodes", []) + node.get("floating_nodes", [])
        if not children and node.get("type") == "con" and node.get("pid"):
            # leaf node with a pid = actual window
            ids.append(node["id"])
        for child in children:
            ids.extend(self._collect_leaf_con_ids(child))
        return ids

    def _prune_dead_windows(self):
        """remove entries for windows that no longer exist"""
        result = subprocess.run(
            ["swaymsg", "-t", "get_tree", "-r"],
            capture_output=True, text=True, check=True
        )
        tree = json.loads(result.stdout)
        live_ids = set(self._collect_con_ids(tree))
        self.modified_windows &= live_ids

    def _collect_con_ids(self, node: dict) -> list[int]:
        """collect all con_ids from tree"""
        ids = []
        if "id" in node:
            ids.append(node["id"])
        for child in node.get("nodes", []) + node.get("floating_nodes", []):
            ids.extend(self._collect_con_ids(child))
        return ids

    def update_focus_title(self):
        """handle focus change: restore old, decorate new"""
        focused = self._get_focused_window()
        
        new_id = focused["id"] if focused else None
        
        # no change
        if new_id == self.current_focused_id:
            return
        
        # restore previous
        if self.current_focused_id is not None:
            self._restore_window_title(self.current_focused_id)
        
        # decorate new
        if focused and new_id is not None:
            self._set_window_title(new_id, ACTIVE_WINDOW_TITLE)
            self.modified_windows.add(new_id)
        
        self.current_focused_id = new_id
        
        # periodic cleanup
        if len(self.modified_windows) > 50:
            self._prune_dead_windows()

    def _get_visible_workspace_for_output(self, output_name: str) -> Optional[str]:
        workspaces = self._get_workspaces()
        for ws in workspaces:
            if ws.get("output") == output_name and ws.get("visible"):
                return ws.get("name")
        return None

    def _pick_image_for_workspace(self, ws_name: str) -> Optional[dict]:
        # return cached choice if we've already picked for this workspace
        if ws_name in self.workspace_image_cache:
            return self.workspace_image_cache[ws_name]

        ws_config = self.config.get("workspaces", {})
        images = ws_config.get(ws_name) or ws_config.get("default")
        if not images:
            return None

        choice = random.choice(images)
        self.workspace_image_cache[ws_name] = choice
        return choice

    def _get_cached_path(self, src: Path | None, canvas_w: int, canvas_h: int, img_width: int | None) -> Path:
        if src is None:
            return CACHE_DIR / f"solid_{canvas_w}x{canvas_h}.png"
        src_hash = hashlib.md5(str(src).encode()).hexdigest()[:12]
        return CACHE_DIR / f"{src.stem}_{src_hash}_{canvas_w}x{canvas_h}_w{img_width}.png"

    def _generate_letterboxed(self, src: Path, canvas_w: int, canvas_h: int, img_width: int, dest: Path):
        bg_color = self.config.get("background_color", BACKGROUND_COLOR)
        subprocess.run([
            "magick",
            "-size", f"{canvas_w}x{canvas_h}",
            f"xc:{bg_color}",
            "(", str(src), "-resize", f"{img_width}x", ")",
            "-gravity", "NorthWest",
            "-composite",
            str(dest)
        ], check=True)

    def _ensure_image(self, src: Path, canvas_w: int, canvas_h: int, img_width: int) -> Path:
        cached = self._get_cached_path(src, canvas_w, canvas_h, img_width)
        if not cached.exists():
            self._generate_letterboxed(src, canvas_w, canvas_h, img_width, cached)
        return cached

    def _set_wallpaper(self, output_name: str, image_path: Optional[Path]):
        if output_name in self.swaybg_procs:
            self.swaybg_procs[output_name].terminate()
            self.swaybg_procs[output_name].wait()

        if image_path is None:
            proc = subprocess.Popen([
                "swaybg",
                "-o", output_name,
                "-c", BACKGROUND_COLOR.strip("#"),
            ], stdout=subprocess.DEVNULL, stderr=subprocess.DEVNULL)
        else:
            proc = subprocess.Popen([
                "swaybg",
                "-o", output_name,
                "-i", str(image_path),
                "-m", "fill"
            ], stdout=subprocess.DEVNULL, stderr=subprocess.DEVNULL)
        self.swaybg_procs[output_name] = proc

    def update_all_outputs(self):
        outputs = self._get_outputs()
        for output in outputs:
            if not output.get("active"):
                continue

            name = output["name"]
            mode = output.get("current_mode", {})
            canvas_w = mode.get("width", 1920)
            canvas_h = mode.get("height", 1080)
            scale_factor = output.get("scale", 1.0)

            ws_name = self._get_visible_workspace_for_output(name)
            if not ws_name:
                continue

            ws_key = ws_name.split(":")[0]
            img_entry = self._pick_image_for_workspace(ws_key)

            final_image: Optional[Path] = None
            if img_entry:
                img_width = int(img_entry["width"] * scale_factor)
                src_image = IMAGE_DIR / img_entry["path"]
                if src_image.exists():
                    final_image = self._ensure_image(src_image, canvas_w, canvas_h, img_width)

            # only update if state changed
            new_state = (ws_key, final_image)
            if self.current_state.get(name) == new_state:
                continue

            self.current_state[name] = new_state
            self._set_wallpaper(name, final_image)

    def cleanup(self):
        self._restore_all_titles()
        for proc in self.swaybg_procs.values():
            proc.terminate()
        for proc in self.swaybg_procs.values():
            proc.wait()

    def run(self):
        self.update_all_outputs()
        self._apply_default_title_to_all()
        self.update_focus_title()

        proc = subprocess.Popen(
            ["swaymsg", "-t", "subscribe", "-m", '["workspace", "output", "window"]'],
            stdout=subprocess.PIPE, text=True
        )

        try:
            for line in proc.stdout:
                try:
                    event = json.loads(line)
                    change = event.get("change")
                    
                    # workspace/output events
                    if change in ("focus", "init", "move", "unspecified"):
                        self.update_all_outputs()
                    
                    # window events - focus changes
                    if change in ("focus", "new", "close", "title"):
                        self.update_focus_title()
                        
                except json.JSONDecodeError:
                    continue
        except KeyboardInterrupt:
            pass
        finally:
            proc.terminate()
            self.cleanup()


if __name__ == "__main__":
    kill_old_instance()
    daemon = WallpaperDaemon()
    
    # handle signals for clean shutdown
    def handle_signal(signum, frame):
        daemon.cleanup()
        PIDFILE.unlink(missing_ok=True)
        sys.exit(0)
    
    signal.signal(signal.SIGTERM, handle_signal)
    signal.signal(signal.SIGINT, handle_signal)
    
    try:
        daemon.run()
    finally:
        PIDFILE.unlink(missing_ok=True)
