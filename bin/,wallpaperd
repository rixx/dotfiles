#!/usr/bin/env -S uv run --script
"""
sway workspace-aware wallpaper daemon.
listens for workspace changes and sets per-output backgrounds
based on the first visible workspace on each output.
also decorates the focused window title.
"""

import atexit
import hashlib
import json
import os
import random
import signal
import subprocess
import sys
from contextlib import suppress
from pathlib import Path
from typing import Optional

CONFIG_PATH = Path("~/.config/sway/wallpapers.json").expanduser()
IMAGE_DIR = Path("~/lib/pics/wallpapers/marginalia").expanduser()
CACHE_DIR = Path("~/.cache/sway-wallpapers").expanduser()
BACKGROUND_COLOR = "#fdf6e3"
ACTIVE_WINDOW_TITLE = "<span size='10pt'>⸻ ❧ ꧁   ⁂   ꧂ ☙ ⸻</span>"
DEFAULT_TITLE_FORMAT = "<span size='10pt'>⸻ ❧ ꧁   %title   ꧂ ☙ ⸻</span>"


def kill_old_instances():
    """Kill any other instances of this script, and orphaned swaybg processes."""
    with suppress(Exception):
        subprocess.run(["pkill", "-x", "swaybg"], capture_output=True)

    my_pid = os.getpid()
    script_path = Path(__file__).resolve()
    result = subprocess.run(
        ["pgrep", "-f", str(script_path)],
        capture_output=True,
        text=True,
    )
    if result.returncode != 0:
        return
    for line in result.stdout.strip().split("\n"):
        with suppress(ValueError, ProcessLookupError, PermissionError):
            pid = int(line.strip())
            if pid != my_pid:
                comm = Path(f"/proc/{pid}/comm").read_text().strip()
                if comm.startswith("python"):
                    os.kill(pid, signal.SIGTERM)


class WallpaperDaemon:
    def __init__(self):
        self.config = self._load_config()
        CACHE_DIR.mkdir(parents=True, exist_ok=True)

        # Set up caches for processes, images, etc
        self.swaybg_procs: dict[str, subprocess.Popen] = {}
        self.current_state: dict[str, tuple[str, Optional[Path]]] = {}
        self.workspace_image_cache: dict[str, dict] = {}
        self.modified_windows: set[int] = set()
        self.current_focused_id: Optional[int] = None
        atexit.register(self._restore_all_titles)

    def _load_config(self) -> dict:
        if not CONFIG_PATH.exists():
            raise FileNotFoundError(f"config not found: {CONFIG_PATH}")
        with open(CONFIG_PATH) as f:
            return json.load(f)

    def _swaymsg_query(self, command: str):
        result = subprocess.run(
            ["swaymsg", "-t", command, "-r"],
            capture_output=True,
            text=True,
            check=True,
        )
        return json.loads(result.stdout)

    def _swaymsg_cmd(self, command: str):
        return subprocess.run(
            ["swaymsg", command],
            capture_output=True,
            text=True,
            check=False,
        )

    def _get_outputs(self) -> list[dict]:
        return self._swaymsg_query("get_outputs")

    def _get_workspaces(self) -> list[dict]:
        return self._swaymsg_query("get_workspaces")

    def _get_window_tree(self) -> dict:
        return self._swaymsg_query("get_tree")

    def _find_focused(self, node: dict) -> Optional[dict]:
        if node.get("focused") and node.get("type") == "con" and not node.get("nodes"):
            return node
        for child in node.get("nodes", []) + node.get("floating_nodes", []):
            if found := self._find_focused(child):
                return found

    def _set_window_title(self, con_id: int, title: str):
        escaped = title.replace('"', '\\"')
        self._swaymsg_cmd(f'[con_id={con_id}] title_format "{escaped}"')

    def _restore_window_title(self, con_id: int):
        if con_id not in self.modified_windows:
            return
        self.modified_windows.discard(con_id)
        self._set_window_title(con_id, DEFAULT_TITLE_FORMAT)

    def _restore_all_titles(self):
        for con_id in list(self.modified_windows):
            self._restore_window_title(con_id)
        self.current_focused_id = None

    def _apply_default_title_to_all(self):
        tree = self._get_window_tree()
        for con_id in self._collect_leaf_con_ids(tree):
            self._restore_window_title(con_id)
            self.modified_windows.add(con_id)

    def _collect_leaf_con_ids(self, node: dict) -> list[int]:
        ids = []
        children = node.get("nodes", []) + node.get("floating_nodes", [])
        if not children and node.get("type") == "con" and node.get("pid"):
            ids.append(node["id"])
        for child in children:
            ids.extend(self._collect_leaf_con_ids(child))
        return ids

    def _prune_dead_windows(self):
        tree = self._get_window_tree()
        live_ids = set(self._collect_con_ids(tree))
        self.modified_windows &= live_ids

    def _collect_con_ids(self, node: dict) -> list[int]:
        ids = []
        if "id" in node:
            ids.append(node["id"])
        for child in node.get("nodes", []) + node.get("floating_nodes", []):
            ids.extend(self._collect_con_ids(child))
        return ids

    def update_focus_title(self):
        focused = self._find_focused(self._get_window_tree())
        new_id = focused["id"] if focused else None
        if new_id == self.current_focused_id:
            return

        if self.current_focused_id is not None:
            self._restore_window_title(self.current_focused_id)

        if focused and new_id is not None:
            self._set_window_title(new_id, ACTIVE_WINDOW_TITLE)
            self.modified_windows.add(new_id)

        self.current_focused_id = new_id

        if len(self.modified_windows) > 50:
            self._prune_dead_windows()

    def _get_visible_workspace_for_output(self, output_name: str) -> Optional[str]:
        workspaces = self._get_workspaces()
        for ws in workspaces:
            if ws.get("output") == output_name and ws.get("visible"):
                return ws.get("name")

    def _pick_image_for_workspace(self, ws_name: str) -> Optional[dict]:
        if ws_name in self.workspace_image_cache:
            return self.workspace_image_cache[ws_name]

        ws_config = self.config.get("workspaces", {})
        images = ws_config.get(ws_name) or ws_config.get("default")
        if not images:
            return None

        choice = random.choice(images)
        self.workspace_image_cache[ws_name] = choice
        return choice

    def _get_cached_path(
        self, src: Path, canvas_w: int, canvas_h: int, img_width: int | None
    ) -> Path:
        src_hash = hashlib.md5(str(src).encode()).hexdigest()[:12]
        return (
            CACHE_DIR / f"{src.stem}_{src_hash}_{canvas_w}x{canvas_h}_w{img_width}.png"
        )

    def _generate_letterboxed(
        self, src: Path, canvas_w: int, canvas_h: int, img_width: int, dest: Path
    ):
        bg_color = self.config.get("background_color", BACKGROUND_COLOR)
        subprocess.run(
            [
                "magick",
                "-size",
                f"{canvas_w}x{canvas_h}",
                f"xc:{bg_color}",
                "(",
                str(src),
                "-resize",
                f"{img_width}x",
                ")",
                "-gravity",
                "NorthWest",
                "-composite",
                str(dest),
            ],
            check=True,
        )

    def _ensure_image(
        self, src: Path, canvas_w: int, canvas_h: int, img_width: int
    ) -> Path:
        cached = self._get_cached_path(src, canvas_w, canvas_h, img_width)
        if not cached.exists():
            self._generate_letterboxed(src, canvas_w, canvas_h, img_width, cached)
        return cached

    def _set_wallpaper(self, output_name: str, image_path: Optional[Path]):
        if output_name in self.swaybg_procs:
            self.swaybg_procs[output_name].terminate()
            self.swaybg_procs[output_name].wait()

        if image_path is None or not image_path.exists():
            proc = subprocess.Popen(
                [
                    "swaybg",
                    "-o",
                    output_name,
                    "-c",
                    BACKGROUND_COLOR.strip("#"),
                ],
                stdout=subprocess.DEVNULL,
                stderr=subprocess.DEVNULL,
            )
        else:
            proc = subprocess.Popen(
                ["swaybg", "-o", output_name, "-i", str(image_path), "-m", "fill"],
                stdout=subprocess.DEVNULL,
                stderr=subprocess.DEVNULL,
            )
        self.swaybg_procs[output_name] = proc

    def update_all_outputs(self):
        for output in self._get_outputs():
            if not output.get("active"):
                continue

            name = output["name"]
            mode = output.get("current_mode", {})
            canvas_w = mode.get("width", 1920)
            canvas_h = mode.get("height", 1080)
            scale_factor = output.get("scale", 1.0)

            ws_name = self._get_visible_workspace_for_output(name)
            if not ws_name:
                continue

            ws_key = ws_name.split(":")[0]
            img_entry = self._pick_image_for_workspace(ws_key)

            final_image: Optional[Path] = None
            if img_entry:
                img_width = int(img_entry["width"] * scale_factor)
                src_image = IMAGE_DIR / img_entry["path"]
                if src_image.exists():
                    final_image = self._ensure_image(
                        src_image, canvas_w, canvas_h, img_width
                    )

            new_state = (ws_key, final_image)
            if self.current_state.get(name) == new_state:
                continue

            self.current_state[name] = new_state
            self._set_wallpaper(name, final_image)

    def cleanup(self):
        self._restore_all_titles()
        for proc in self.swaybg_procs.values():
            proc.terminate()
        for proc in self.swaybg_procs.values():
            proc.wait()

    def run(self):
        self.update_all_outputs()
        self._apply_default_title_to_all()
        self.update_focus_title()

        proc = subprocess.Popen(
            ["swaymsg", "-t", "subscribe", "-m", '["workspace", "output", "window"]'],
            stdout=subprocess.PIPE,
            text=True,
        )

        try:
            for line in proc.stdout:
                try:
                    event = json.loads(line)
                    change = event.get("change")

                    # workspace/output events
                    if change in ("focus", "init", "move", "unspecified"):
                        self.update_all_outputs()

                    # window events - focus changes
                    if change in ("focus", "new", "close", "title"):
                        self.update_focus_title()

                except json.JSONDecodeError:
                    continue
        except KeyboardInterrupt:
            pass
        finally:
            proc.terminate()
            self.cleanup()


if __name__ == "__main__":
    kill_old_instances()
    daemon = WallpaperDaemon()

    def handle_signal(signum, frame):
        daemon.cleanup()
        sys.exit(0)

    signal.signal(signal.SIGTERM, handle_signal)
    signal.signal(signal.SIGINT, handle_signal)

    daemon.run()
